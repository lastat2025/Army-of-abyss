name": "rest-express",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js"
  },
  "dependencies": {
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-dialog": "^1.1.7",
    "@tanstack/react-query": "^5.60.5",
    "drizzle-orm": "^0.39.1",
    "ethers": "^6.15.0",
    "express": "^4.21.2",
    "framer-motion": "^11.13.1",
    "react": "^18.3.1",
    "wouter": "^3.3.5",
    "zod": "^3.24.2"
    // ... and many more UI/styling dependencies
  }
}
üóÑÔ∏è Database Schema (shared/schema.ts)
export const warriors = pgTable("warriors", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  tokenId: integer("token_id").notNull().unique(),
  name: text("name").notNull(),
  rank: text("rank").notNull(),
  power: integer("power").notNull(),
  defense: integer("defense").notNull(),
  speed: integer("speed").notNull(),
  ability: text("ability").notNull(),
  emoji: text("emoji").notNull(),
  rarity: text("rarity").notNull(),
  maxSupply: integer("max_supply").notNull().default(1),
  currentSupply: integer("current_supply").notNull().default(0),
});
export const purchases = pgTable("purchases", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  buyerAddress: text("buyer_address").notNull(),
  warriorId: varchar("warrior_id").notNull(),
  priceInEth: text("price_in_eth").notNull(),
  transactionHash: text("transaction_hash"),
  status: text("status").notNull().default("pending"),
  timestamp: text("timestamp").notNull(),
});
export const ownedWarriors = pgTable("owned_warriors", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  ownerAddress: text("owner_address").notNull(),
  warriorId: varchar("warrior_id").notNull(),
  purchaseId: varchar("purchase_id").notNull(),
  acquiredAt: text("acquired_at").notNull(),
});
üîß Server API Routes (server/routes.ts)
// Get all warriors
app.get("/api/warriors", async (req, res) => {
  const warriors = await storage.getWarriors();
  res.json(warriors);
});
// Purchase warrior NFT
app.post("/api/purchase", async (req, res) => {
  const purchase = insertPurchaseSchema.parse(req.body);
  const newPurchase = await storage.createPurchase(purchase);
  res.json(newPurchase);
});
// Update purchase status (for payment confirmation)
app.patch("/api/purchase/:id/status", async (req, res) => {
  const { id } = req.params;
  const { status, transactionHash } = req.body;
  
  const updatedPurchase = await storage.updatePurchaseStatus(id, status, transactionHash);
  
  if (status === "completed") {
    await storage.createOwnedWarrior({
      ownerAddress: updatedPurchase.buyerAddress,
      warriorId: updatedPurchase.warriorId,
      purchaseId: updatedPurchase.id,
      acquiredAt: new Date().toISOString()
    });
  }
  res.json(updatedPurchase);
});
// Get owned warriors by wallet address
app.get("/api/owned/:address", async (req, res) => {
  const ownedWarriors = await storage.getOwnedWarriorsByAddress(req.params.address);
  res.json(ownedWarriors);
});
üéÆ Main Game Component (client/src/pages/game.tsx)
export default function Game() {
  const [battleScore, setBattleScore] = useState(0);
  const [walletAddress, setWalletAddress] = useState<string | null>(null);
  const [selectedWarriorForPurchase, setSelectedWarriorForPurchase] = useState<Warrior | null>(null);
  const { data: warriors = [] } = useQuery<Warrior[]>({
    queryKey: ["/api/warriors"],
  });
  const { data: ownedWarriors = [] } = useQuery<any[]>({
    queryKey: ["/api/owned", walletAddress],
    enabled: !!walletAddress,
  });
  const engageCharacter = (warrior: Warrior) => {
    // Check if player owns this NFT
    const isOwned = ownedWarriors.some(owned => owned.warriorId === warrior.id);
    if (!isOwned) {
      setSelectedWarriorForPurchase(warrior);
      addLogEntry(`üîí ${warrior.name} requires NFT ownership to battle!`);
      return;
    }
    // Battle logic with explosions and scoring...
    createExplosion();
    createBattleParticles();
    addLogEntry(`‚öîÔ∏è NFT #${warrior.tokenId} ${warrior.name} engages enemy forces!`);
    
    const damageDealt = Math.floor(Math.random() * warrior.power) + warrior.power;
    setBattleScore(prev => prev + damageDealt);
  };
  return (
    <div className="min-h-screen bg-gradient-to-br from-abyss-dark via-abyss-surface to-abyss-muted">
      {/* Game header with wallet connection */}
      <header>
        <h1 className="font-orbitron font-black text-6xl">ARMY OF THE ABYSS</h1>
        <p>üíé Collect NFT Warriors ‚Ä¢ Battle ‚Ä¢ Dominate the Abyss</p>
        <WalletConnection onWalletConnected={setWalletAddress} />
      </header>
      {/* Warriors grid */}
      <main className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-6">
        {warriors.map((warrior) => (
          <CharacterCard 
            warrior={warrior} 
            onEngage={() => engageCharacter(warrior)}
            onPurchase={() => setSelectedWarriorForPurchase(warrior)}
            isOwned={ownedWarriors.some(owned => owned.warriorId === warrior.id)}
          />
        ))}
      </main>
      {/* Purchase Modal */}
      <PurchaseModal
        warrior={selectedWarriorForPurchase}
        isOpen={!!selectedWarriorForPurchase}
        onClose={() => setSelectedWarriorForPurchase(null)}
        walletAddress={walletAddress}
      />
    </div>
  );
}
üÉè Character Card Component (client/src/components/character-card.tsx)
export default function CharacterCard({ warrior, onEngage, onPurchase, isOwned }: CharacterCardProps) {
  return (
    <motion.div className="holographic-card rounded-xl p-4 border-2 relative overflow-hidden hover:scale-105">
      {/* NFT Badge */}
      <div className="absolute -top-2 -right-2 bg-abyss-gold text-black px-3 py-1 rounded-full text-xs font-bold">
        NFT #{warrior.tokenId}
      </div>
      
      {/* Character info */}
      <div className="text-center mb-4">
        <motion.div className="character-avatar w-16 h-16 mx-auto mb-3 bg-gradient-to-br from-abyss-primary to-abyss-secondary rounded-full flex items-center justify-center text-2xl border-2 border-white" animate={{ rotate: 360 }} transition={{ duration: 4, repeat: Infinity }}>
          {warrior.emoji}
        </motion.div>
        <h3 className="font-orbitron font-bold text-lg text-white">{warrior.name}</h3>
        <p className="text-abyss-accent text-sm">{warrior.rank}</p>
      </div>
      
      {/* Stats */}
      <div className="grid grid-cols-2 gap-2 mb-4">
        <div className="stat-box bg-abyss-muted/50 rounded-lg p-2 text-center border border-abyss-primary/30">
          <div className="text-xs text-gray-400">POWER</div>
          <div className="text-lg font-bold text-abyss-primary">{warrior.power}</div>
        </div>
        {/* ... more stats */}
      </div>
      
      {/* Purchase/Ownership Status */}
      {isOwned ? (
        <div className="mt-3 bg-abyss-gold text-black p-2 rounded-lg text-center font-bold">
          ‚úì NFT OWNED - BATTLE READY!
        </div>
      ) : (
        <button onClick={onPurchase} className="mt-3 w-full bg-gradient-to-r from-green-600 to-emerald-600 text-white p-2 rounded-lg font-bold">
          üíé MINT NFT
        </button>
      )}
    </motion.div>
  );
}
üí∞ Purchase Modal (client/src/components/purchase-modal.tsx)
const PAYMENT_WALLET = "0x9E1d192bd9c4dc67617D47381090DDb84db8d6C5";
export default function PurchaseModal({ warrior, isOpen, onClose, walletAddress }: PurchaseModalProps) {
  const handlePurchase = async () => {
    if (typeof window.ethereum !== 'undefined') {
      const priceInEth = getRarityPrice(warrior.rarity);
      const valueInWei = `0x${(parseFloat(priceInEth) * Math.pow(10, 18)).toString(16)}`;
      
      const transactionParameters = {
        to: PAYMENT_WALLET,
        from: walletAddress,
        value: valueInWei,
        data: `0x${Buffer.from(`Purchase ${warrior.name} (${warrior.id})`).toString('hex')}`
      };
      // Send transaction
      const txHash = await ethereum.request({
        method: 'eth_sendTransaction',
        params: [transactionParameters],
      });
      // Create purchase record
      await createPurchaseMutation.mutateAsync({
        buyerAddress: walletAddress,
        warriorId: warrior.id,
        priceInEth: priceInEth,
        transactionHash: txHash,
        status: "pending",
        timestamp: new Date().toISOString()
      });
      toast({ title: "NFT Mint Transaction Sent! üíé", description: `Minting ${warrior.name} NFT #${warrior.tokenId}...` });
    }
  };
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="bg-gradient-to-br from-abyss-surface to-abyss-muted border-2 border-abyss-primary">
        <DialogHeader>
          <DialogTitle className="font-orbitron text-2xl text-center text-abyss-accent">
            Mint Warrior NFT
          </DialogTitle>
        </DialogHeader>
        
        {/* Warrior preview and pricing details */}
        <Button onClick={handlePurchase} className="w-full bg-gradient-to-r from-abyss-primary to-abyss-secondary">
          üíé Mint NFT for {priceInEth} ETH
        </Button>
      </DialogContent>
    </Dialog>
  );
}
üîó Wallet Connection (client/src/components/wallet-connection.tsx)
export default function WalletConnection({ onWalletConnected, onWalletDisconnected, connectedAddress }: WalletConnectionProps) {
  const connectWallet = async () => {
    if (typeof window.ethereum === 'undefined') {
      toast({ title: "MetaMask Not Found", description: "Please install MetaMask to connect your wallet.", variant: "destructive" });
      return;
    }
    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
    
    if (accounts.length > 0) {
      onWalletConnected(accounts[0]);
      toast({ title: "Wallet Connected!", description: `Connected to ${accounts[0].substring(0, 6)}...${accounts[0].substring(-4)}` });
    }
  };
  return connectedAddress ? (
    <div className="flex items-center gap-3">
      <div className="bg-abyss-muted/50 px-3 py-2 rounded-lg border border-abyss-primary/30">
        <span className="text-xs text-gray-400">Connected:</span>
        <div className="text-sm text-abyss-accent font-mono">{connectedAddress.substring(0, 6)}...{connectedAddress.substring(-4)}</div>
      </div>
      <Button onClick={() => onWalletDisconnected()} variant="outline">Disconnect</Button>
    </div>
  ) : (
    <Button onClick={connectWallet} className="bg-gradient-to-r from-abyss-primary to-abyss-secondary">
      Connect Wallet
    </Button>
  );
}
üé® Custom Styling (client/src/index.css)
:root {
  /* Custom Abyss Theme Colors */
  --abyss-primary: hsl(336 100% 50%);
  --abyss-secondary: hsl(336 100% 40%);
  --abyss-accent: hsl(336 100% 60%);
  --abyss-dark: hsl(245 22.2% 8.0392%);
  --abyss-surface: hsl(245 15.3846% 10.1961%);
  --abyss-muted: hsl(245 19.1489% 12.5490%);
  --abyss-gold: hsl(51 100% 50%);
}
.holographic-card {
  background: linear-gradient(145deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.2);
}
.animate-pulse-glow {
  animation: pulse-glow 2s ease-in-out infinite alternate;
}
@keyframes pulse-glow {
  from { text-shadow: 0 0 5px #ff1493, 0 0 10px #ff1493, 0 0 15px #ff1493; }
  to { text-shadow: 0 0 10px #ff1493, 0 0 20px #ff1493, 0 0 30px #ff1493; }
}
üöÄ Key Features:
19 Unique NFT Warriors with token IDs, rarities, and limited supplies
Ethereum Integration with MetaMask for real payments to your wallet: 0x9E1d192bd9c4dc67617D47381090DDb84db8d6C5
Rarity-Based Pricing: Common (0.01 ETH) ‚Üí Mythic (0.25 ETH)
Ownership Verification: Only owned NFTs can battle
Real-Time Battle System with animations and scoring
PostgreSQL Database for persistent data
Responsive Design with cyberpunk theme
PWA Support for mobile deployment
Your complete Army of the Abyss NFT battle game is ready for deployment on any platform that supports Node.js and PostgreSQL!

Agent is ready
